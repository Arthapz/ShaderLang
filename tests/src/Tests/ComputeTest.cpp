#include <Tests/ShaderUtils.hpp>
#include <NZSL/ShaderBuilder.hpp>
#include <NZSL/Parser.hpp>
#include <catch2/catch_test_macros.hpp>
#include <cctype>

TEST_CASE("compute", "[Shader]")
{
	SECTION("Simple texture copy")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.0")]
module;

[auto_binding]
external
{
	input_tex: texture2D[f32, readonly, rgba8],
	output_tex: texture2D[f32, writeonly, rgba8]
}

struct Input
{
	[builtin(global_invocation_indices)] indices: vec3[u32]
}

[entry(compute)]
[workgroup(32, 16*2, 1)]
fn main(input: Input)
{
	let value = input_tex.Read(vec2[i32](input.indices.xy));
	output_tex.Write(vec2[i32](input.indices.xy), value);
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
		shaderModule = SanitizeModule(*shaderModule);

		nzsl::GlslWriter::Environment glslEnv;
		glslEnv.glES = true;
		glslEnv.glMajorVersion = 3;
		glslEnv.glMinorVersion = 1;

		ExpectGLSL(*shaderModule, R"(
#version 310 es

// compute shader - this file was generated by NZSL compiler (Nazara Shading Language)

precision highp int;
#if GL_FRAGMENT_PRECISION_HIGH
precision highp float;
precision highp image2D;
#else
precision mediump float;
precision mediump image2D;
#endif

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// header end

layout(rgba8) uniform readonly image2D input_tex;
layout(rgba8) uniform writeonly image2D output_tex;

struct Input
{
	uvec3 indices;
};

void main()
{
	Input input_;
	input_.indices = gl_GlobalInvocationID;

	vec4 value = imageLoad(input_tex, ivec2(input_.indices.xy));
	imageStore(output_tex, ivec2(input_.indices.xy), value);
})", glslEnv);

		ExpectNZSL(*shaderModule, R"(
[nzsl_version("1.0")]
module;

[auto_binding(true)]
external
{
	[set(0), binding(0)] input_tex: texture2D[f32, readonly, rgba8],
	[set(0), binding(1)] output_tex: texture2D[f32, writeonly, rgba8]
}

struct Input
{
	[builtin(global_invocation_indices)] indices: vec3[u32]
}

[entry(comp), workgroup(32, 32, 1)]
fn main(input: Input)
{
	let value: vec4[f32] = input_tex.Read(vec2[i32](input.indices.xy));
	output_tex.Write(vec2[i32](input.indices.xy), value);
})");

		ExpectSPIRV(*shaderModule, R"(
      OpCapability Capability(Shader)
      OpMemoryModel AddressingModel(Logical) MemoryModel(GLSL450)
      OpEntryPoint ExecutionModel(GLCompute) %22 "main" %12
      OpExecutionMode %22 ExecutionMode(LocalSize) 32 32 1
      OpName %22 "main"
      OpName %8 "Input"
      OpMemberName %8 0 "indices"
      OpName %4 "input_tex"
      OpName %5 "output_tex"
      OpName %12 "global_invocation_indices"
      OpDecorate %4 Decoration(Binding) 0
      OpDecorate %4 Decoration(DescriptorSet) 0
      OpDecorate %5 Decoration(Binding) 1
      OpDecorate %5 Decoration(DescriptorSet) 0
      OpDecorate %12 Decoration(BuiltIn) BuiltIn(GlobalInvocationId)
      OpMemberDecorate %8 0 Decoration(Offset) 0
 %1 = OpTypeFloat 32
 %2 = OpTypeImage %1 Dim(Dim2D) 2 0 0 2 ImageFormat(Rgba8)
 %3 = OpTypePointer StorageClass(UniformConstant) %2
 %6 = OpTypeInt 32 0
 %7 = OpTypeVector %6 3
 %8 = OpTypeStruct %7
 %9 = OpTypeVoid
%10 = OpTypeFunction %9
%11 = OpTypePointer StorageClass(Input) %7
%13 = OpTypeInt 32 1
%14 = OpConstant %13 i32(0)
%15 = OpTypePointer StorageClass(Function) %7
%16 = OpTypePointer StorageClass(Function) %8
%17 = OpConstant %13 i32(1)
%18 = OpTypeVector %6 2
%19 = OpTypeVector %13 2
%20 = OpTypeVector %1 4
%21 = OpTypePointer StorageClass(Function) %20
 %4 = OpVariable %3 StorageClass(UniformConstant)
 %5 = OpVariable %3 StorageClass(UniformConstant)
%12 = OpVariable %11 StorageClass(Input)
%22 = OpFunction %9 FunctionControl(0) %10
%23 = OpLabel
%24 = OpVariable %21 StorageClass(Function)
%25 = OpVariable %16 StorageClass(Function)
%26 = OpAccessChain %15 %25 %14
      OpCopyMemory %26 %12
%27 = OpLoad %2 %4
%28 = OpAccessChain %15 %25 %14
%29 = OpLoad %7 %28
%30 = OpVectorShuffle %18 %29 %29 0 1
%31 = OpBitcast %19 %30
%32 = OpImageRead %20 %27 %31
      OpStore %24 %32
%33 = OpLoad %2 %5
%34 = OpAccessChain %15 %25 %14
%35 = OpLoad %7 %34
%36 = OpVectorShuffle %18 %35 %35 0 1
%37 = OpBitcast %19 %36
%38 = OpLoad %20 %24
      OpImageWrite %33 %37 %38
      OpReturn
      OpFunctionEnd)", {}, true);
	}
}
